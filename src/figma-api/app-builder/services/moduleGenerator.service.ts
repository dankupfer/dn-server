// figma-api/app-builder/services/moduleGenerator.service.ts

/**
 * MODULE GENERATOR SERVICE
 * 
 * Generates React Native module files for components:
 * - Creates module folders under /generated-{appId}/
 * - Generates index.tsx wrapper components
 * - Creates configuration files (screenData.json or config.json)
 * - Handles naming conventions (PascalCase, kebab-case)
 */

import * as path from 'path';
import * as fs from 'fs/promises';
import {
    RouteComponent,
    ModuleConfig,
    GeneratedModule,
    GeneratedFile,
    ModuleGenerationResult,
    NormalisedComponent
} from '../types/appBuilder.types';

/**
 * Main module generation function
 * Generates all module files for categorised components
 */
export async function generateModules(
    appId: string,
    routes: RouteComponent[],
    basePath: string
): Promise<ModuleGenerationResult> {
    const modules: GeneratedModule[] = [];
    const errors: string[] = [];
    let totalFiles = 0;

    // Create base generated folder
    const generatedBasePath = path.join(basePath, 'src', 'modules', 'feature', `generated-${appId}`);

    try {
        await ensureDirectoryExists(generatedBasePath);
    } catch (error) {
        errors.push(`Failed to create base directory: ${error instanceof Error ? error.message : 'Unknown error'}`);
        return {
            success: false,
            modules: [],
            totalFiles: 0,
            errors
        };
    }

    // Generate each module
    for (const route of routes) {
        try {
            const moduleConfig = createModuleConfig(appId, route, generatedBasePath);
            const generatedModule = await generateModule(moduleConfig);

            modules.push(generatedModule);
            totalFiles += generatedModule.files.length;

            if (!generatedModule.success && generatedModule.error) {
                errors.push(`Module '${route.id}': ${generatedModule.error}`);
            }
        } catch (error) {
            errors.push(`Failed to generate module '${route.id}': ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    const allSuccessful = modules.every(m => m.success);

    return {
        success: allSuccessful && errors.length === 0,
        modules,
        totalFiles,
        errors
    };
}

/**
 * Create module configuration
 */
function createModuleConfig(
    appId: string,
    route: RouteComponent,
    basePath: string
): ModuleConfig {
    const componentName = generateComponentName(route.id);
    const fileName = generateFileName(route.id);
    const modulePath = path.join(basePath, fileName);

    return {
        appId,
        component: route,
        outputPath: modulePath,
        componentName,
        fileName
    };
}

/**
 * Generate a single module
 */
async function generateModule(config: ModuleConfig): Promise<GeneratedModule> {
    const files: GeneratedFile[] = [];

    try {
        // Create module directory
        await ensureDirectoryExists(config.outputPath);

        // Generate index.tsx
        const indexFile = await generateIndexFile(config);
        files.push(indexFile);

        // Generate configuration file (screenData.json or config.json)
        const configFile = await generateConfigFile(config);
        files.push(configFile);

        return {
            moduleConfig: config,
            files,
            success: true
        };
    } catch (error) {
        return {
            moduleConfig: config,
            files,
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
        };
    }
}

/**
 * Generate index.tsx file
 */
async function generateIndexFile(config: ModuleConfig): Promise<GeneratedFile> {
    const component = config.component.component;
    const isJourney = component.componentType === 'Journey';

    const content = isJourney
        ? generateJourneyIndexContent(config)
        : generateScreenBuilderIndexContent(config);

    const filePath = path.join(config.outputPath, 'index.tsx');

    try {
        await fs.writeFile(filePath, content, 'utf-8');
        return {
            path: filePath,
            type: 'index',
            content,
            written: true
        };
    } catch (error) {
        return {
            path: filePath,
            type: 'index',
            content,
            written: false
        };
    }
}

/**
 * Generate ScreenBuilder index.tsx content
 */
function generateScreenBuilderIndexContent(config: ModuleConfig): string {
    const { componentName } = config;

    return `// Generated by DN Figma Bridge
import React from 'react';
import { ScreenBuilder, type ScreenConfig } from '@dankupfer/dn-components';
import screenData from './screenData.json';

interface ${componentName}Props {
  screenWidth: number;
}

const ${componentName}: React.FC<${componentName}Props> = ({ screenWidth }) => {
  const config = screenData as ScreenConfig;
  
  return (
    <ScreenBuilder 
      config={config} 
      screenWidth={screenWidth}
      testID="${config.component.id}"
    />
  );
};

export default ${componentName};
`;
}

/**
 * Generate Journey index.tsx content
 */
function generateJourneyIndexContent(config: ModuleConfig): string {
    const { componentName, component } = config;
    const journeyType = component.component.journeyType;
    const journeyConfig = component.component.journeyConfig;

    // Determine which Journey component to use
    const journeyComponent = journeyType === 'AssistJourney' ? 'AssistJourney' : 'CoreJourney';

    return `// Generated by DN Figma Bridge
import React from 'react';
import { ${journeyComponent} } from '@dankupfer/dn-components';
import config from './config.json';

interface ${componentName}Props {
  screenWidth: number;
  customerData?: any;
}

const ${componentName}: React.FC<${componentName}Props> = ({ screenWidth, customerData }) => {
  return (
    <${journeyComponent}
      screenWidth={screenWidth}
      ${journeyType === 'CoreJourney' ? 'customerData={customerData}' : ''}
      ${journeyType === 'AssistJourney' ? 'enableTTS={config.enableTTS}' : ''}
      ${journeyType === 'AssistJourney' ? 'enableGemini={config.enableGemini}' : ''}
      ${journeyType === 'CoreJourney' && journeyConfig?.customerId ? 'customerId={config.customerId}' : ''}
      ${journeyType === 'AssistJourney' ? `assistantConfig={{
        serverUrl: config.serverUrl,
        debug: config.debug,
        useMockMode: config.useMockMode
      }}` : ''}
    />
  );
};

export default ${componentName};
`;
}

/**
 * Generate configuration file (screenData.json or config.json)
 */
async function generateConfigFile(config: ModuleConfig): Promise<GeneratedFile> {
    const component = config.component.component;
    const isJourney = component.componentType === 'Journey';

    const fileName = isJourney ? 'config.json' : 'screenData.json';
    const content = isJourney
        ? generateJourneyConfig(component)
        : generateScreenBuilderConfig(component);

    const filePath = path.join(config.outputPath, fileName);
    const type = isJourney ? 'config' : 'screenData';

    try {
        await fs.writeFile(filePath, content, 'utf-8');
        return {
            path: filePath,
            type,
            content,
            written: true
        };
    } catch (error) {
        return {
            path: filePath,
            type,
            content,
            written: false
        };
    }
}

/**
 * Generate Journey config.json content
 */
function generateJourneyConfig(component: NormalisedComponent): string {
    const journeyConfig = component.journeyConfig;

    if (!journeyConfig) {
        // Fallback default config
        return JSON.stringify({
            journeyType: 'CoreJourney',
            enableTTS: false,
            enableGemini: false,
            serverUrl: 'ws://localhost:3001/api/assist',
            debug: false,
            useMockMode: true
        }, null, 2);
    }

    const config: any = {
        journeyType: journeyConfig.journeyType,
        serverUrl: journeyConfig.serverUrl || 'ws://localhost:3001/api/assist',
        debug: journeyConfig.debug ?? false,
        useMockMode: journeyConfig.useMockMode ?? true
    };

    if (journeyConfig.journeyType === 'AssistJourney') {
        config.enableTTS = journeyConfig.enableTTS ?? false;
        config.enableGemini = journeyConfig.enableGemini ?? false;
    }

    if (journeyConfig.journeyType === 'CoreJourney' && journeyConfig.customerId) {
        config.customerId = journeyConfig.customerId;
    }

    return JSON.stringify(config, null, 2);
}

/**
 * Generate ScreenBuilder screenData.json content
 * Placeholder structure - actual screen data would come from Figma
 */
function generateScreenBuilderConfig(component: NormalisedComponent): string {
    // TODO: In future, this should extract actual screen data from Figma
    // For now, create a placeholder structure

    const config = {
        scrollable: true,
        style: {},
        components: [
            {
                type: 'SectionHeader',
                props: {
                    id: `${component.id}-header`,
                    title: generateDisplayName(component.id)
                },
                style: {
                    marginBottom: 16
                }
            },
            {
                type: 'ServiceCard',
                props: {
                    id: `${component.id}-placeholder`,
                    title: 'Generated Screen',
                    description: `This is a generated screen for ${component.id}. Replace with actual Figma data.`,
                    icon: { name: 'icons|miscellaneous|settings', color: '#006a4e' },
                    showArrow: false,
                    onPress: '() => console.log("Placeholder pressed")'
                },
                style: {
                    marginBottom: 16
                }
            }
        ]
    };

    return JSON.stringify(config, null, 2);
}

/**
 * Generate component name in PascalCase
 * Examples:
 * - 'summary-screen' → 'SummaryScreen'
 * - 'account-detail' → 'AccountDetail'
 * - 'everyday' → 'Everyday'
 */
function generateComponentName(id: string): string {
    return id
        .split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
}

/**
 * Generate file name in kebab-case
 * Already in kebab-case from ID, just ensure it's clean
 */
function generateFileName(id: string): string {
    return id.toLowerCase().replace(/[^a-z0-9-]/g, '-');
}

/**
 * Generate display name for headers
 * Examples:
 * - 'summary-screen' → 'Summary Screen'
 * - 'account-detail' → 'Account Detail'
 */
function generateDisplayName(id: string): string {
    return id
        .split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}

/**
 * Ensure directory exists, create if it doesn't
 */
async function ensureDirectoryExists(dirPath: string): Promise<void> {
    try {
        await fs.access(dirPath);
    } catch {
        // Directory doesn't exist, create it
        await fs.mkdir(dirPath, { recursive: true });
    }
}

/**
 * Generate import path for a module
 * Returns relative import path from router file to module
 */
export function generateImportPath(
    appId: string,
    fileName: string,
    fromRouterPath: string
): string {
    // Router files are in: src/modules/core/assist-router/
    // Module files are in: src/modules/feature/generated-{appId}/{fileName}/

    // Calculate relative path
    return `../../feature/generated-${appId}/${fileName}`;
}

/**
 * Generate module summary report
 */
export function generateModuleSummary(result: ModuleGenerationResult): string {
    let report = `\n=== MODULE GENERATION REPORT ===\n`;
    report += `Total modules: ${result.modules.length}\n`;
    report += `Total files: ${result.totalFiles}\n`;
    report += `Success: ${result.success ? 'Yes' : 'No'}\n\n`;

    if (result.modules.length > 0) {
        report += `Generated modules:\n`;
        result.modules.forEach(module => {
            const status = module.success ? '✓' : '✗';
            report += `  ${status} ${module.moduleConfig.componentName} (${module.files.length} files)\n`;
            if (!module.success && module.error) {
                report += `      Error: ${module.error}\n`;
            }
        });
        report += `\n`;
    }

    if (result.errors.length > 0) {
        report += `Errors (${result.errors.length}):\n`;
        result.errors.forEach(error => {
            report += `  ✗ ${error}\n`;
        });
        report += `\n`;
    }

    report += `=== END REPORT ===\n`;

    return report;
}

/**
 * Validate generated modules
 * Check that all required files exist and are valid
 */
export async function validateGeneratedModules(
    modules: GeneratedModule[]
): Promise<string[]> {
    const errors: string[] = [];

    for (const module of modules) {
        // Check that index.tsx exists
        const indexFile = module.files.find(f => f.type === 'index');
        if (!indexFile || !indexFile.written) {
            errors.push(`Module '${module.moduleConfig.componentName}': Missing or failed to write index.tsx`);
        }

        // Check that config file exists
        const configFile = module.files.find(f => f.type === 'config' || f.type === 'screenData');
        if (!configFile || !configFile.written) {
            errors.push(`Module '${module.moduleConfig.componentName}': Missing or failed to write configuration file`);
        }

        // Verify files on disk
        for (const file of module.files) {
            if (file.written) {
                try {
                    await fs.access(file.path);
                } catch {
                    errors.push(`Module '${module.moduleConfig.componentName}': File not found on disk: ${file.path}`);
                }
            }
        }
    }

    return errors;
}